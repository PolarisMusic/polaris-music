# Blockchain Configuration
CHAIN_ID=aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906
RPC_URL=https://eos.greymass.com
CONTRACT_ACCOUNT=polarismusic

# ============================================
# Testnet (Jungle4) Configuration
# ============================================
# Use these settings for Jungle4 testnet deployment and testing
# Uncomment and set when deploying to testnet

# Jungle4 Testnet Chain Configuration
# CHAIN_ID=73e4385a2708e6d7048834fbc1079f2fabb17b3c125b146af438971e90716c4d
# RPC_URL=https://jungle4.greymass.com
# CHAIN_WS_URL=wss://jungle4.greymass.com
# CONTRACT_ACCOUNT=polarismusic  # Or use your custom account name

# Testnet Private Key (SECURITY: Generate via Jungle4 faucet, never commit real keys)
# TESTNET_PRIVATE_KEY=5K...

# Node Environment (switches between local dev and testnet mode)
# NODE_ENV=testnet

# SSL/TLS Security for Blockchain RPC Connections (SEC-03)
# RPC_CA_CERT_PATH: Path to custom CA certificate for SSL certificate pinning
#   - Optional: If not set, uses system default CA certificates
#   - Use for enhanced MITM protection when connecting to blockchain RPC nodes
#   - Example: RPC_CA_CERT_PATH=/etc/ssl/certs/blockchain-ca.pem
#   - To extract CA cert from server: openssl s_client -connect eos.greymass.com:443 -showcerts
# RPC_CA_CERT_PATH=

# RPC_REJECT_UNAUTHORIZED: Enforce TLS certificate verification
#   - true (default): Strict certificate verification (RECOMMENDED for production)
#   - false: Disable certificate verification (DEV ONLY - allows self-signed certs)
#   - WARNING: Setting to 'false' makes connections vulnerable to MITM attacks
# RPC_REJECT_UNAUTHORIZED=true

# RPC_CIPHERS: Specify allowed TLS cipher suites for enhanced security
#   - Optional: If not set, uses Node.js defaults
#   - Use to enforce strong ciphers and disable weak algorithms
#   - Example: RPC_CIPHERS=ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384
#   - See: https://nodejs.org/api/tls.html#tls_modifying_the_default_tls_cipher_suite
# RPC_CIPHERS=

# Chain Ingestion Source (T6)
# Options: substreams (primary, recommended) | ship (NOT IMPLEMENTED - will fail)
# CRITICAL: SHiP mode is non-functional (drops binary messages, requires ABI deserialization)
# Use CHAIN_SOURCE=substreams for production and development
CHAIN_SOURCE=substreams

# Ingest Mode: Controls whether write endpoints apply changes immediately or event-only
# Options: chain (default) | dev
#   - chain: Write endpoints (POST /api/identity/*, etc.) store events only.
#            Neo4j mutations happen when ingestion sees the anchored on-chain event.
#            Use for production and staging.
#   - dev:   Write endpoints store events AND apply changes immediately.
#            Fast feedback for local development; events are still stored for replay.
INGEST_MODE=dev

# SHiP (State History Plugin) Configuration - Only used if CHAIN_SOURCE=ship
# WARNING: SHiP binary deserialization is NOT implemented
# Setting CHAIN_SOURCE=ship will cause immediate startup failure
# If SHiP support is required, see backend/src/indexer/shipEventSource.js for implementation notes
# Recommended libraries: eosio-ship-reader, @greymass/eosio
SHIP_URL=ws://localhost:8080
START_BLOCK=0
END_BLOCK=0xffffffff

# Neo4j Graph Database
GRAPH_URI=bolt://localhost:7687
GRAPH_USER=neo4j
# SECURITY: Use a strong password in production (e.g., openssl rand -base64 32)
GRAPH_PASSWORD=<secure-password>

# Neo4j Schema Management
# GRAPH_INIT_SCHEMA: Initialize database schema (constraints, indexes) on startup
#   - true: Run initializeSchema() during server start (recommended for dev/staging)
#   - false: Skip schema initialization (use for prod if managing schema separately)
#   - Default: true (runs unless explicitly set to 'false')
GRAPH_INIT_SCHEMA=true

# GRAPH_RUN_MIGRATIONS: Run pending database migrations on startup
#   - true: Automatically run migrations that haven't been applied yet
#   - false: Skip migrations (manual migration required)
#   - Default: false (must be explicitly enabled for safety)
#   - WARNING: Only enable in controlled environments; migrations can modify data
#   - Current migrations:
#     001-unify-id-property: Backfills universal 'id' from entity-specific IDs
#     002-normalize-status-values: Converts 'canonical'/'provisional' → 'ACTIVE'/'PROVISIONAL'
#   - See: backend/docs/migrations/ for runbooks
GRAPH_RUN_MIGRATIONS=false

# Redis Cache
REDIS_HOST=localhost
REDIS_PORT=6379
# SECURITY: Use a strong password in production (e.g., openssl rand -base64 32)
REDIS_PASSWORD=<secure-password>

# IPFS Storage
# Default: Single node (minimal mode) - easy deployment
# IPFS_URLS: Comma-separated list of IPFS API endpoints
#   - Single node: IPFS_URLS=http://localhost:5001
#   - Multi-node (best-effort redundancy): IPFS_URLS=http://localhost:5001,http://localhost:5002
#   - First node is primary (for writes), others are secondary (replication)
#   - Docker Compose with ipfs2: IPFS_URLS=http://ipfs:5001,http://ipfs2:5001
IPFS_URLS=http://localhost:5001

# IPFS_URL: Single IPFS node (DEPRECATED - use IPFS_URLS instead)
# IPFS_URL=http://localhost:5001

# External Pinning Provider (optional, best-effort)
# PIN_PROVIDER: none|pinata|web3storage|custom (default: none)
#   - none: No external pinning (local IPFS nodes only)
#   - pinata: Pin to Pinata.cloud (requires PIN_PROVIDER_TOKEN)
#   - web3storage: Pin to Web3.Storage (requires PIN_PROVIDER_TOKEN)
#   - custom: Pin to custom endpoint (requires PIN_PROVIDER_ENDPOINT)
PIN_PROVIDER=none

# PIN_PROVIDER_TOKEN: API token/JWT for pinning provider
#   - Required for pinata and web3storage
#   - Optional for custom (if authentication needed)
# PIN_PROVIDER_TOKEN=

# PIN_PROVIDER_ENDPOINT: Custom pinning endpoint URL
#   - Only required if PIN_PROVIDER=custom
#   - Expects POST ${endpoint} with JSON body: { cid: "bafy..." }
# PIN_PROVIDER_ENDPOINT=

# PIN_PROVIDER_TIMEOUT_MS: Timeout for pinning requests (milliseconds)
#   - Default: 8000 (8 seconds)
#   - Pinning failures do NOT fail event creation (best-effort)
PIN_PROVIDER_TIMEOUT_MS=8000

# Pinata Configuration (for testnet/production with public IPFS access)
# Get your API keys from https://app.pinata.cloud
# NOTE: These are DUMMY keys for example only - replace with real keys for deployment
# PINATA_API_KEY=dummy_key_1234567890abcdef
# PINATA_SECRET_API_KEY=dummy_secret_abcdef1234567890

# S3/MinIO Storage
S3_ENDPOINT=http://localhost:9000
# SECURITY: Use strong credentials in production (e.g., openssl rand -hex 16)
S3_ACCESS_KEY=<secure-access-key>
S3_SECRET_KEY=<secure-secret-key>
S3_BUCKET=polaris-events
S3_REGION=us-east-1

# Storage Encryption at Rest (SEC-04)
# STORAGE_ENCRYPTION_KEY: 256-bit AES key for encrypting event data in S3 and Redis
#   - Optional: If not set, data is stored unencrypted (development only)
#   - Required in production: MUST be set for production deployments
#   - Format: 64 hexadecimal characters (32 bytes = 256 bits)
#   - Generate: openssl rand -hex 32
#   - Algorithm: AES-256-GCM with authenticated encryption
#   - Scope: Encrypts full event JSON in S3/Redis (IPFS canonical bytes remain unencrypted for CID derivability)
#   - CRITICAL: Store this key securely (e.g., AWS Secrets Manager, HashiCorp Vault)
#   - WARNING: Losing this key means losing access to all encrypted event data
#   - Key rotation: Not currently supported - set once before first event storage
# STORAGE_ENCRYPTION_KEY=

# API Configuration
NODE_ENV=development
# PORT=3001 for local development (Docker uses 3000)
PORT=3001
# CORS_ORIGIN supports comma-separated list for multiple dev origins
# Example: http://localhost:5173,http://localhost:4173
CORS_ORIGIN=http://localhost:5173
LOG_LEVEL=debug

# Event Ingestion Batching (PERF-03)
# INGESTION_ENABLE_BATCHING: Enable batch processing for high-volume event ingestion
#   - true (default): Queue events and process in batches for improved throughput
#   - false: Process events immediately (lower latency, lower throughput)
#   - Batching significantly improves performance under high load (>10 events/sec)
# INGESTION_ENABLE_BATCHING=true

# INGESTION_BATCH_SIZE: Maximum events per batch
#   - Default: 100 events
#   - Range: 10-1000 (larger batches = better throughput but higher memory usage)
#   - Batch processes immediately when this size is reached
# INGESTION_BATCH_SIZE=100

# INGESTION_BATCH_TIMEOUT_MS: Maximum time to wait before processing partial batch
#   - Default: 1000ms (1 second)
#   - Range: 100-10000ms (lower = lower latency, higher = better batching efficiency)
#   - Ensures events don't wait indefinitely in low-volume scenarios
# INGESTION_BATCH_TIMEOUT_MS=1000

# Security: Ingestion & Admin Endpoint Authentication
# INGEST_API_KEY: Shared secret required in X-API-Key header for ingestion endpoint.
#   - Protects: POST /api/ingest/anchored-event (Substreams sink)
#   - Does NOT protect: /api/events/prepare, /api/events/create (public, signature-verified)
#   - REQUIRED in chain mode (INGEST_MODE=chain) and production (NODE_ENV=production)
#     Server will refuse to start without it in these modes.
#   - When set: Protected endpoints require X-API-Key: <this value>
#   - When unset: Protected endpoints are open (local dev only!)
#   - In production: ALWAYS set this to a strong random value (e.g., openssl rand -hex 32)
#   - Rate limiting (30 req/min per IP) is always active on all write endpoints
#   - NOTE: /api/events/* endpoints are public by design — they rely on cryptographic
#     signature verification (not shared secrets) for authentication. For additional
#     protection in production, use reverse-proxy rate limiting (Cloudflare/WAF).
# INGEST_API_KEY=

# Security: Signature Verification
# ALLOW_UNSIGNED_EVENTS: Bypass cryptographic signature verification for events
#   - WARNING: DO NOT set to 'true' in production - undermines verifiability guarantees
#   - Only use for isolated testing with mock data (e.g., unit tests)
#   - Default: undefined (strict verification enforced)
#   - Tests automatically set this to 'true' via test/setup.js
# ALLOW_UNSIGNED_EVENTS=true

# Security: Account Authorization
# REQUIRE_ACCOUNT_AUTH: Verify that event signing key is authorized for the anchoring account
#   - true (default): Verify public key is authorized for account@permission via RPC
#   - false: Skip account authorization check (smoke tests/dev only)
#   - WARNING: Default is true (secure). Only set to 'false' for smoke tests.
#   - In production, this ensures only authorized keys can create events for accounts
# REQUIRE_ACCOUNT_AUTH=true

# Development: Server-side Event Signing (DEV/TEST ONLY)
# DEV_SIGNER_PRIVATE_KEY: EOSIO private key for dev-only server-side signing
#   - WARNING: NEVER use in production (NODE_ENV=production)
#   - Only enabled when this env var is set AND NODE_ENV !== 'production'
#   - Enables POST /api/events/dev-sign endpoint for smoke tests
#   - Example test key (DO NOT use real keys!): 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3
#   - In production, signing must happen client-side with user wallets
# DEV_SIGNER_PRIVATE_KEY=
